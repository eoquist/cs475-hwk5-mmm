#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"
// funny
#include <unistd.h>

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 * @param matrix pointer to a 2D array
 */
double **mmm_init(double **matrix, int fillWithRandom)
{
	// Set the seed value to the current time
  	srand(time(NULL));

	matrix = (double **)calloc(DIMENSION, sizeof(double *));
	for (int i = 0; i < DIMENSION; i++)
	{
		matrix[i] = (double *)calloc(DIMENSION, sizeof(double));
		if(fillWithRandom == 1){
			for (int j = 0; j < DIMENSION; j++)
			{
				matrix[i][j] = (double)(rand() % 100);
			}
		}
	}
	return matrix;
}

/**
 * Reset a given matrix to zeroes
 * @param matrix pointer to a 2D arrayF
 * @param dimension integer width of a square matrix
 */
void mmm_reset(double **matrix)
{
	printf("mmm_reset started\n");
	for (int i = 0; i < DIMENSION; i++)
	{
		for (int j = 0; i < DIMENSION; j++)
		{
			matrix[i][j] = 0;
		}
	}
	printf("mmm_reset ended\n");
}

/**
 * Free up memory allocated to all matrices
 * @param matrix pointer to a 2D array
 * @param dimension integer width of a square matrix
 */
void mmm_freeup(double **matrix)
{
	for (int i = 0; i < DIMENSION; i++)
	{
		free(matrix[i]);
		matrix[i] = NULL;
	}
	free(matrix);
	matrix = NULL;
}

/**
 * Makes a transposed version of BASE_MATRIX ... for a later me
*/
void mmm_transpose(){
	for (int row = 0; row < DIMENSION; row++) {
		for (int column = row + 1; column < DIMENSION; column++) {
			BASE_MATRIX_TRANSPOSE[row][column] = BASE_MATRIX[column][row];
  		}
	}
}

/**
 * Sequential MMM
 */
double **mmm_seq()
{
    for (int row = 0; row < DIMENSION; row++) {
        for (int column = 0; column < DIMENSION; column++) {
            double product = 0.0;
            for (int k = 0; k < DIMENSION; k++) {
				// k = col of 1st, row of 2nd
                product += BASE_MATRIX[row][k] * BASE_MATRIX[k][column]; 
            }
            MATRIX_PRODUCT_SEQUENTIAL[row][column] = product;
        }
    }
	return MATRIX_PRODUCT_SEQUENTIAL;
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args_void)
{
	thread_args *args = (thread_args*)args_void;
	int start_row = args->start_row;
	int end_row = args->end_row;
	
	// Compute partial products for assigned rows
	for (int row = start_row; row <= end_row; row++) {
		for (int column = 0; column < DIMENSION; column++) {
			double product = 0.0;
			for (int k = 0; k < DIMENSION; k++) {
				product += BASE_MATRIX[row][k] * BASE_MATRIX[k][column]; 
			}
			MATRIX_PRODUCT_PARALLEL[row][column] = product;
		}
	}
	return NULL;
}
// MATRIX_PRODUCT_PARALLEL[row - start_row][column] += BASE_MATRIX[row][k] * BASE_MATRIX[k][column];

/**
 * Verifies the correctness between the matrix product generated by
 * the sequential run and the parallel run using fabs().
 * @param matrix_A pointer to a 2D array
 * @param matrix_B pointer to a 2D array
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify(double **matrix_A, double **matrix_B)
{
	double error = 0.0;
    for (int i = 0; i < DIMENSION; i++) {
        for (int j = 0; j < DIMENSION; j++) {
            error += fabs(matrix_A[i][j] - matrix_B[i][j]);
        }
    }
    return error;
	
}

/**
 * Final print before program termination. This should print all relevant stats for the user.
*/
void mmm_print(char* mode, double avgTime_seq, double avgTime_par){
	// this is super cool and not redundant at all :)
	char *mode_fullname; 
	if(strcmp(mode,"S")==0){
		mode_fullname = malloc(strlen("sequential") + 1);
		strcpy(mode_fullname,"sequential");
	}
	else if(strcmp(mode,"P")==0){
		mode_fullname = malloc(strlen("parallel") + 1);
		strcpy(mode_fullname,"parallel");
	}

	printf("========\n");
	printf("mode: %s\n", mode_fullname);
	printf("thread count: %d\n", NUM_THREADS);
	printf("size: %d\n", DIMENSION);
	printf("========\n");
	printf("Sequential Time (avg of %d runs): %.6f sec\n", MMM_RUNS - 1, avgTime_seq);
	if(strcmp(mode,"P")==0){
		printf("Parallel Time (avg of %d runs): %.6f sec\n", MMM_RUNS - 1, avgTime_par);
		double speedup = avgTime_seq / avgTime_par;
		printf("Speedup: %.6f sec\n", speedup);
	}
	free(mode_fullname);
	mode_fullname = NULL;
}

/** Testing purposes */
void print_matrix(double **matrix) {
    double max_value = 0;

    // Find the maximum number of digits before and after the decimal point
    for (int i = 0; i < DIMENSION; i++) {
        for (int j = 0; j < DIMENSION; j++) {
            double value = matrix[i][j];
            int before_decimal = (int)value;
            int after_decimal = (int)((value - before_decimal) * 1000000);

            int digits_before = 1;
            while (before_decimal / 10 > 0) {
                before_decimal /= 10;
                digits_before++;
            }

            int digits_after = 1;
            while (after_decimal / 10 > 0) {
                after_decimal /= 10;
                digits_after++;
            }

            int digits = digits_before + digits_after + 1; // +1 for the decimal point
            if (digits > max_value) {
                max_value = digits;
            }
        }
    }

    // Print the matrix with aligned columns
    for (int i = 0; i < DIMENSION; i++) {
        for (int j = 0; j < DIMENSION; j++) {
            printf("%*.*f ", (int)max_value, 6, matrix[i][j]);
        }
        printf("\n");
    }
}

/**
 * Assumed that the badapple repo is saved in the same directory as 
 * the one holding 'cs475-hwk5-mmm'
 * @author of repo being used https://github.com/leafyao8621/badapple
*/
void funny(){
	// ask david about running make within a make file?
	chdir("../badapple");
	printf("======================================\n");
	printf("Hope you enjoy!\n");
	system("make -s");

	// https://askubuntu.com/questions/179630/execute-a-command-on-local-computer-from-a-connected-remote-ssh-host 
	// https://askubuntu.com/questions/70560/why-am-i-getting-this-connection-to-pulseaudio-failed-error
	// https://askubuntu.com/questions/1056153/pulseaudio-not-working-daemon-already-running-and-no-permission-for-home-folder
	// https://askubuntu.com/questions/179630/execute-a-command-on-local-computer-from-a-connected-remote-ssh-host
	// https://dhole.github.io/post/pulseaudio_multiple_users/


	// https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/Network/
	// X forwarding
	// xprop -root | grep PULSE -----> xprop:  unable to open display ''
	// Enable X11 forwarding
	// While doing ssh use the option -X to enable X11 forwarding
	// $ ssh username@hostname -X

	
	// need to talk to david about making this functional
	// chdir("../cs475-hwk5-mmm");
	// int ret_val = system("PULSE_SERVER=localhost mpg123 mystery.mp3");
	// int ret_val = system("mpg123 mystery.mp3");
	// if(0 != ret_val){perror("There was an error\n");}

	sleep(3);
	chdir("../badapple");
	system("./main");
}